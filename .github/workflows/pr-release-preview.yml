name: PR Release Preview

on:
  pull_request:
    types: [opened, synchronize, reopened, labeled, unlabeled]
    branches:
      - main

permissions:
  contents: read
  pull-requests: write

jobs:
  preview:
    name: Preview Release Impact
    runs-on: ubuntu-latest
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          cache: 'pnpm'
          cache-dependency-path: pnpm-lock.yaml

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Analyze release impact
        id: analyze
        run: |
          # Get current version
          CURRENT_VERSION=$(grep -Po '"version": *"\K[^"]*' package.json | sed 's/-rc\.[0-9]*//')
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT

          # Get base branch (main)
          git fetch origin main:main

          # Get commits in this PR
          COMMITS=$(git log --oneline origin/main..HEAD)
          echo "commits<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMITS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Analyze commit types
          HAS_BREAKING=false
          HAS_FEAT=false
          HAS_FIX=false
          BREAKING_COMMITS=""
          FEAT_COMMITS=""
          FIX_COMMITS=""

          while IFS= read -r commit; do
            if [[ $commit =~ feat!:|^[^:]+\!:|BREAKING[[:space:]]CHANGE ]]; then
              HAS_BREAKING=true
              BREAKING_COMMITS+="$commit"$'\n'
            elif [[ $commit =~ ^[a-f0-9]+[[:space:]]feat(\(|:) ]]; then
              HAS_FEAT=true
              FEAT_COMMITS+="$commit"$'\n'
            elif [[ $commit =~ ^[a-f0-9]+[[:space:]]fix(\(|:) ]]; then
              HAS_FIX=true
              FIX_COMMITS+="$commit"$'\n'
            fi
          done <<< "$COMMITS"

          # Determine version bump
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

          WILL_RELEASE=false
          RELEASE_TYPE="none"
          NEW_VERSION=""

          if [ "$HAS_BREAKING" = true ]; then
            WILL_RELEASE=true
            RELEASE_TYPE="major"
            NEW_VERSION="$((MAJOR + 1)).0.0"
          elif [ "$HAS_FEAT" = true ]; then
            WILL_RELEASE=true
            RELEASE_TYPE="minor"
            NEW_VERSION="$MAJOR.$((MINOR + 1)).0"
          elif [ "$HAS_FIX" = true ]; then
            WILL_RELEASE=true
            RELEASE_TYPE="patch"
            NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
          fi

          echo "will_release=$WILL_RELEASE" >> $GITHUB_OUTPUT
          echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "has_breaking=$HAS_BREAKING" >> $GITHUB_OUTPUT
          echo "has_feat=$HAS_FEAT" >> $GITHUB_OUTPUT
          echo "has_fix=$HAS_FIX" >> $GITHUB_OUTPUT

          echo "breaking_commits<<EOF" >> $GITHUB_OUTPUT
          echo "$BREAKING_COMMITS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "feat_commits<<EOF" >> $GITHUB_OUTPUT
          echo "$FEAT_COMMITS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "fix_commits<<EOF" >> $GITHUB_OUTPUT
          echo "$FIX_COMMITS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Generate release preview comment
        id: generate
        env:
          WILL_RELEASE: ${{ steps.analyze.outputs.will_release }}
          RELEASE_TYPE: ${{ steps.analyze.outputs.release_type }}
          CURRENT_VERSION: ${{ steps.analyze.outputs.current_version }}
          NEW_VERSION: ${{ steps.analyze.outputs.new_version }}
          HAS_BREAKING: ${{ steps.analyze.outputs.has_breaking }}
          HAS_FEAT: ${{ steps.analyze.outputs.has_feat }}
          HAS_FIX: ${{ steps.analyze.outputs.has_fix }}
          BREAKING_COMMITS: ${{ steps.analyze.outputs.breaking_commits }}
          FEAT_COMMITS: ${{ steps.analyze.outputs.feat_commits }}
          FIX_COMMITS: ${{ steps.analyze.outputs.fix_commits }}
          REPO: ${{ github.repository }}
        run: |
          # Generate comment body
          COMMENT="## üöÄ Release Preview"$'\n\n'

          if [ "$WILL_RELEASE" != "true" ]; then
            COMMENT+="**No release will be created** ‚ùå"$'\n\n'
            COMMENT+="This PR contains only non-release commits (docs, chore, style, refactor, test, ci)."$'\n\n'
            COMMENT+="üí° To trigger a release, include commits with types:"$'\n'
            COMMENT+="- \`feat:\` for minor version bump"$'\n'
            COMMENT+="- \`fix:\` for patch version bump"$'\n'
            COMMENT+="- \`feat!:\` or \`BREAKING CHANGE:\` for major version bump"$'\n'
          else
            # Determine emoji and installer info
            if [ "$RELEASE_TYPE" = "major" ]; then
              EMOJI="üí•"
              INSTALLER="+ Windows Installer üì¶"
            elif [ "$RELEASE_TYPE" = "minor" ]; then
              EMOJI="‚ú®"
              INSTALLER="(no installer)"
            else
              EMOJI="üêõ"
              INSTALLER="(no installer)"
            fi
            
            COMMENT+="**${EMOJI} ${RELEASE_TYPE^^} Release will be created** ‚úÖ"$'\n\n'
            COMMENT+="\`\`\`"$'\n'
            COMMENT+="Current: v${CURRENT_VERSION}"$'\n'
            COMMENT+="Next:    v${NEW_VERSION}"$'\n'
            COMMENT+="\`\`\`"$'\n\n'
            COMMENT+="**Artifacts**: GitHub Release ${INSTALLER}"$'\n\n'
            
            # Breaking changes
            if [ "$HAS_BREAKING" = "true" ] && [ -n "$BREAKING_COMMITS" ]; then
              COMMENT+="### üí• Breaking Changes"$'\n\n'
              while IFS= read -r line; do
                [ -n "$line" ] && COMMENT+="- ${line}"$'\n'
              done <<< "$BREAKING_COMMITS"
              COMMENT+=$'\n'
            fi
            
            # Features
            if [ "$HAS_FEAT" = "true" ] && [ -n "$FEAT_COMMITS" ]; then
              COMMENT+="### ‚ú® Features"$'\n\n'
              while IFS= read -r line; do
                [ -n "$line" ] && COMMENT+="- ${line}"$'\n'
              done <<< "$FEAT_COMMITS"
              COMMENT+=$'\n'
            fi
            
            # Bug fixes
            if [ "$HAS_FIX" = "true" ] && [ -n "$FIX_COMMITS" ]; then
              COMMENT+="### üêõ Bug Fixes"$'\n\n'
              while IFS= read -r line; do
                [ -n "$line" ] && COMMENT+="- ${line}"$'\n'
              done <<< "$FIX_COMMITS"
              COMMENT+=$'\n'
            fi
            
            COMMENT+="---"$'\n\n'
            COMMENT+="### üìã Release Process"$'\n\n'
            COMMENT+="1. PR merged to \`main\`"$'\n'
            COMMENT+="2. Auto-sync workflow: \`main\` ‚Üí \`release\`"$'\n'
            COMMENT+="3. semantic-release creates \`v${NEW_VERSION}\`"$'\n'
            
            if [ "$RELEASE_TYPE" = "major" ]; then
              COMMENT+="4. Windows installer builds (~5-10 min)"$'\n'
              COMMENT+="5. Installer uploaded to GitHub Release"$'\n'
            else
              COMMENT+="4. GitHub Release created (no installer)"$'\n'
            fi
            
            COMMENT+=$'\n'
            COMMENT+="üìö [Release Strategy Documentation](https://github.com/${REPO}/blob/main/RELEASE_STRATEGY.md)"$'\n'
          fi

          # Save to file for gh CLI
          echo "$COMMENT" > /tmp/pr-comment.md
          echo "comment_file=/tmp/pr-comment.md" >> $GITHUB_OUTPUT

      - name: Post or update PR comment (native)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REPO: ${{ github.repository }}
        run: |
          # Find existing release preview comment (use text without emoji for reliability)
          EXISTING_COMMENT=$(gh pr view "$PR_NUMBER" --json comments \
            --jq '.comments[] | select(.author.login == "github-actions" and (.body | contains("Release Preview"))) | .id' \
            | head -1)

          if [ -n "$EXISTING_COMMENT" ]; then
            echo "Found existing release preview comment: $EXISTING_COMMENT"
            
            # Get numeric comment ID via GraphQL
            COMMENT_DB_ID=$(gh api graphql -f query='
              query($nodeId: ID!) {
                node(id: $nodeId) {
                  ... on IssueComment {
                    databaseId
                  }
                }
              }
            ' -f nodeId="$EXISTING_COMMENT" --jq '.data.node.databaseId')
            
            if [ -n "$COMMENT_DB_ID" ]; then
              echo "Updating comment #$COMMENT_DB_ID..."
              gh api "repos/$REPO/issues/comments/$COMMENT_DB_ID" \
                -X PATCH \
                -F body=@"${{ steps.generate.outputs.comment_file }}"
              echo "‚úÖ Updated release preview comment"
            else
              echo "‚ö†Ô∏è Could not get numeric ID, creating new comment instead"
              gh pr comment "$PR_NUMBER" --body-file "${{ steps.generate.outputs.comment_file }}"
            fi
          else
            # Create new comment
            echo "Creating new release preview comment..."
            gh pr comment "$PR_NUMBER" --body-file "${{ steps.generate.outputs.comment_file }}"
            echo "‚úÖ Created new release preview comment"
          fi
