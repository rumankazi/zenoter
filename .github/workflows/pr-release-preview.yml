name: PR Release Preview

on:
  pull_request:
    types: [opened, synchronize, reopened, labeled, unlabeled]
    branches:
      - main

permissions:
  contents: read
  pull-requests: write

jobs:
  preview:
    name: Preview Release Impact
    runs-on: ubuntu-latest
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version-file: '.nvmrc'
          cache: 'pnpm'
          cache-dependency-path: pnpm-lock.yaml

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run semantic-release dry-run
        id: analyze
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get current version
          CURRENT_VERSION=$(grep -Po '"version": *"\K[^"]*' package.json)
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT

          # Run semantic-release in dry-run mode to get the actual next version
          # Redirect to capture output
          OUTPUT=$(pnpm exec semantic-release --dry-run --branches release 2>&1 || true)

          echo "Semantic-release dry-run output:"
          echo "$OUTPUT"

          # Extract new version from output
          if echo "$OUTPUT" | grep -q "The next release version is"; then
            NEW_VERSION=$(echo "$OUTPUT" | grep -Po "The next release version is \K[0-9]+\.[0-9]+\.[0-9]+")
            echo "will_release=true" >> $GITHUB_OUTPUT
            echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
            
            # Determine release type
            IFS='.' read -r NEW_MAJOR NEW_MINOR NEW_PATCH <<< "$NEW_VERSION"
            IFS='.' read -r CUR_MAJOR CUR_MINOR CUR_PATCH <<< "$CURRENT_VERSION"
            
            if [ "$NEW_MAJOR" -gt "$CUR_MAJOR" ]; then
              echo "release_type=major" >> $GITHUB_OUTPUT
            elif [ "$NEW_MINOR" -gt "$CUR_MINOR" ]; then
              echo "release_type=minor" >> $GITHUB_OUTPUT
            else
              echo "release_type=patch" >> $GITHUB_OUTPUT
            fi
          elif echo "$OUTPUT" | grep -q "There are no relevant changes"; then
            echo "will_release=false" >> $GITHUB_OUTPUT
            echo "release_type=none" >> $GITHUB_OUTPUT
            echo "new_version=" >> $GITHUB_OUTPUT
          else
            # Fallback: no release
            echo "will_release=false" >> $GITHUB_OUTPUT
            echo "release_type=none" >> $GITHUB_OUTPUT
            echo "new_version=" >> $GITHUB_OUTPUT
          fi

          # Get commits for display
          git fetch origin main:main
          COMMITS=$(git log --oneline origin/main..HEAD)
          echo "commits<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMITS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Generate release preview comment
        id: generate
        env:
          WILL_RELEASE: ${{ steps.analyze.outputs.will_release }}
          RELEASE_TYPE: ${{ steps.analyze.outputs.release_type }}
          CURRENT_VERSION: ${{ steps.analyze.outputs.current_version }}
          NEW_VERSION: ${{ steps.analyze.outputs.new_version }}
          COMMITS: ${{ steps.analyze.outputs.commits }}
          REPO: ${{ github.repository }}
        run: |
          # Generate comment body
          COMMENT="## üöÄ Release Preview"$'\n\n'

          if [ "$WILL_RELEASE" != "true" ]; then
            COMMENT+="**No release will be created** ‚ùå"$'\n\n'
            COMMENT+="This PR contains only non-release commits (docs, chore, style, refactor, test, ci)."$'\n\n'
            COMMENT+="üí° To trigger a release, include commits with types:"$'\n'
            COMMENT+="- \`feat:\` for minor version bump"$'\n'
            COMMENT+="- \`fix:\` for patch version bump"$'\n'
            COMMENT+="- \`feat!:\` or \`BREAKING CHANGE:\` for major version bump"$'\n'
          else
            # Determine emoji and installer info
            if [ "$RELEASE_TYPE" = "major" ]; then
              EMOJI="üí•"
              INSTALLER="+ Windows Installer üì¶"
            elif [ "$RELEASE_TYPE" = "minor" ]; then
              EMOJI="‚ú®"
              INSTALLER="(no installer)"
            else
              EMOJI="üêõ"
              INSTALLER="(no installer)"
            fi
            
            COMMENT+="**${EMOJI} ${RELEASE_TYPE^^} Release will be created** ‚úÖ"$'\n\n'
            COMMENT+="\`\`\`"$'\n'
            COMMENT+="Current: v${CURRENT_VERSION}"$'\n'
            COMMENT+="Next:    v${NEW_VERSION}"$'\n'
            COMMENT+="\`\`\`"$'\n\n'
            COMMENT+="**Artifacts**: GitHub Release ${INSTALLER}"$'\n\n'
            
            # Show commits
            COMMENT+="### üìù Commits"$'\n\n'
            while IFS= read -r line; do
              [ -n "$line" ] && COMMENT+="- ${line}"$'\n'
            done <<< "$COMMITS"
            COMMENT+=$'\n'
            
            COMMENT+="**Note**: Version determined by semantic-release analysis"$'\n\n'
            
            COMMENT+="---"$'\n\n'
            COMMENT+="### üìã Release Process"$'\n\n'
            COMMENT+="1. PR merged to \`main\`"$'\n'
            COMMENT+="2. Auto-sync: \`main\` ‚Üí \`release\` branch"$'\n'
            COMMENT+="3. semantic-release creates \`v${NEW_VERSION}\`"$'\n'
            
            if [ "$RELEASE_TYPE" = "major" ]; then
              COMMENT+="4. Windows installer builds (~5-10 min)"$'\n'
              COMMENT+="5. Installer uploaded to GitHub Release"$'\n'
            else
              COMMENT+="4. GitHub Release created (no installer)"$'\n'
            fi
            
            COMMENT+=$'\n'
            COMMENT+="üìö [Release Strategy Documentation](https://github.com/${REPO}/blob/main/RELEASE_STRATEGY.md)"$'\n'
          fi

          # Save to file for gh CLI
          echo "$COMMENT" > /tmp/pr-comment.md
          echo "comment_file=/tmp/pr-comment.md" >> $GITHUB_OUTPUT

      - name: Post or update PR comment (native)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REPO: ${{ github.repository }}
        run: |
          # Find existing release preview comment (use text without emoji for reliability)
          EXISTING_COMMENT=$(gh pr view "$PR_NUMBER" --json comments \
            --jq '.comments[] | select(.author.login == "github-actions" and (.body | contains("Release Preview"))) | .id' \
            | head -1)

          if [ -n "$EXISTING_COMMENT" ]; then
            echo "Found existing release preview comment: $EXISTING_COMMENT"
            
            # Get numeric comment ID via GraphQL
            COMMENT_DB_ID=$(gh api graphql -f query='
              query($nodeId: ID!) {
                node(id: $nodeId) {
                  ... on IssueComment {
                    databaseId
                  }
                }
              }
            ' -f nodeId="$EXISTING_COMMENT" --jq '.data.node.databaseId')
            
            if [ -n "$COMMENT_DB_ID" ]; then
              echo "Updating comment #$COMMENT_DB_ID..."
              gh api "repos/$REPO/issues/comments/$COMMENT_DB_ID" \
                -X PATCH \
                -F body=@"${{ steps.generate.outputs.comment_file }}"
              echo "‚úÖ Updated release preview comment"
            else
              echo "‚ö†Ô∏è Could not get numeric ID, creating new comment instead"
              gh pr comment "$PR_NUMBER" --body-file "${{ steps.generate.outputs.comment_file }}"
            fi
          else
            # Create new comment
            echo "Creating new release preview comment..."
            gh pr comment "$PR_NUMBER" --body-file "${{ steps.generate.outputs.comment_file }}"
            echo "‚úÖ Created new release preview comment"
          fi
